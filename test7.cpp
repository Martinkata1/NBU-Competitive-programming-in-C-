/*Test 7 exercise*/
/*Във всеки съюз или обединение от политически субекти (напр. държави) се налага да се приеме система за вземане на решения. Една такава система е да се гласува с "да" или "не", като всяка държава да има определен брой гласове. Решение се взема когато броят на гласовете "да" е по-голям или равен на определена граница. Коалиция се нарича група държави, която гласува с "да" за дадено предложение. Ако сумата от гласовете на държавите в коалицията е по-голяма или равна на определената граница, то предложението се приема и тази коалиция се нарича печеливша. Например през 1958 г. се създава Европейския съюз с точно такава система за вземане на решения. Участващите в съюза държави и гласовете им са: Франция, Германия, Италия - по 4 гласа, Белгия, Холандия -- по 2 гласа, Люксембург - 1 глас. Предложение се приема, ако за него са гласували с "да" 12 от общо 17 гласа. Две печеливши коалиции в съюза са например Франция, Германия и Италия или Франция, Германия, Белгия, Холандия и Люксембург.

Една от няколкото известни мерки за политическата сила на дадена държава в един съюз е индексът на Шапли-Шубик. Ето как се дефинира този индекс. Нека съюзът се състои от държавите - p1,p1,...pn . Разглеждаме всички възможни наредби на тези i държави. Нека индексите i1, i2,...in, 1 <= ij <= n, j = 1,2,...,n  задават една конкретна наредба. Държавата pik, 1<=k <= n се нарича централна за тази наредба, ако коалицията, състояща се от pi1,pi2,...pik-1 , не е печеливша, а коалицията pi1,pi2,...,pik е печеливша. Индекс на Шапли-Шубик за държавата p се нарича отношението на броя на наредбите, в които p е централна към броя на всички възможни наредби. Да се напише програма за пресмятане на индекса на Шапли-Шубик.

Input Format

Стандартният вход съдържа няколко тестови примера. Данните за всеки от примерите са записани на два последователни реда. Първият ред съдържа две цели числа, разделени с един интервал - броят n на държавите в съюза и необходимият брой гласове v за вземане на решение. На следващия ред има n цели положителни числа xi по-малки от 100 (разделени с по един интервал), които са гласовете на участниците в съюза. Входът завършва с ред, съдържащ числото 0.

Constraints

3 <= n <= 20, x1 < v <= En i=1 xi 

Output Format

За всеки пример на стандартния изход трябва да се изведат  числа, на един ред (с резделител един интервал), всяко равно на индекса на Шапли-Шубик, изразен в проценти за поредния участник в съюза. Числата да са с точност точно 1 цифра след десетичната точка.

Sample Input 0

3 51
50 49 1
6 12
4 4 4 2 2 1
0
Sample Output 0

66.7 16.7 16.7
23.3 23.3 23.3 15.0 15.0 0.0
*/
#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>

using namespace std;

uint64_t factorial(int n) {
    uint64_t result = 1;
    for (int i = 1; i <= n; ++i) {
        result *= i;
    }
    return result;
}

vector<double> shapleyShubikIndex(int n, int v, const vector<int>& votes) {
    vector<double> shapleyIndex(n, 0.0);
    uint64_t totalPermutations = factorial(n);
    vector<int> indices(n);
    for (int i = 0; i < n; ++i) indices[i] = i;

    for (bool hasNext = true; hasNext; ) {
        int currentVotes = 0;
        for (int i = 0; i < n; ++i) {
            currentVotes += votes[indices[i]];
            if (currentVotes >= v) {
                shapleyIndex[indices[i]]++;
                break;
            }
        }
        hasNext = next_permutation(indices.begin(), indices.end());
    }

    for (int i = 0; i < n; ++i) {
        shapleyIndex[i] = (shapleyIndex[i] / totalPermutations) * 100.0;
    }

    return shapleyIndex;
}

int main() {
    int n, v;

    while (cin >> n >> v) {
        if (n <= 0 || v < 0) break;
        vector<int> votes(n);
        for (int i = 0; i < n; ++i) {
            cin >> votes[i];
        }

        vector<double> result = shapleyShubikIndex(n, v, votes);
        
        for (size_t i = 0; i < result.size(); ++i) {
            cout << fixed << setprecision(1) << result[i];
            if (i < result.size() - 1) cout << " ";
        }
        cout << endl;
    }

    return 0;
}