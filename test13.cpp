/* Beer Party
Смарти е програмист, който много обичал да пие бира. Един ден той бил поканен на бирено парти и се изправил пред следния проблем. Домакините на партито подредили в дълга редица N бутилки бира от K различни вида. Тъй като бил колекционер на празни бирени бутилки и нямал в колекцията си нито една бутилка от тези  вида, Смарти трябвало да направи нещо, за да си ги занесе в къщи. Eдинственият начин да си вземе няколко бирени бутилки бил, да избере една непрекъсната подредица от тях и да ги изпие. Смарти решил да избере най-късата непрекъсната подредица от бутилки, която съдържа поне по една от всичките K различни вида. Смарти е вече достатъчно пиян и не може да си спомни алгоритъма, който решава тази задача. Помогнете на Смарти, като напишете програма, която определя позициите в редицата на първата и последната бутилки от най-късата непрекъсната подредица, изпълняваща условието. Ако има няколко такива подредици, програмата трябва да намери тази, която се среща най-рано в редицата.

Input Format

Първият ред на стандартния вход съдържа броят T на тестовите случаи. Всеки тестови случай съдържа два реда - първият съдържа числата N и K, разделени с интервал, а вторият – N числа (от 1 до K), разделени с по един интервал.

Constraints

1 <= N <= 10 000 000
1 <= K <= 13000

Output Format

Стандартният изход за всеки тестови случай съдържа две числа – номерата на началната и крайната бутилки в подредицата, която трябва да изпие Смарти.

Sample Input 0

2
5 3
1 3 3 2 1
5 3
1 1 2 2 3
Sample Output 0

3 5
2 5
*/

#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
using namespace std;


int main() {
    int T;
    cin >> T;
    while (T--) {
        int N, K;
        cin >> N >> K;
        vector<int> bottles(N);
        for (int i = 0; i < N; ++i) cin >> bottles[i];

        vector<int> count(K + 1, 0);
        int distinct = 0, start = 0, minLength = N + 1, bestStart = 0, bestEnd = 0;

        for (int end = 0; end < N; ++end) {
            if (++count[bottles[end]] == 1) ++distinct;
            while (distinct == K) {
                if (end - start + 1 < minLength) {
                    minLength = end - start + 1;
                    bestStart = start;
                    bestEnd = end;
                }
                if (--count[bottles[start]] == 0) --distinct;
                ++start;
            }
        }
        cout << bestStart + 1 << " " << bestEnd + 1 << endl;
    }
    return 0;
}